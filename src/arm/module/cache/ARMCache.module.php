<?php

/**
 *
 * @author alanlucian
 *        
 */
class ARMCacheModule extends ARMBaseModuleAbstract {



	/**
	 * @param null $alias
	 * @param bool $useDefaultIfNotFound
	 * @return ARMCacheModule
	 */
	public static function getInstance($alias = NULL, $useDefaultIfNotFound = FALSE) {
		return parent::getInstance($alias, $useDefaultIfNotFound); // TODO: Change the autogenerated stub
	}

	public function setConfig($ob) {
		parent::setConfig($ob); // TODO: Change the autogenerated stub



		if( !is_dir( $this->_config->cache_folder) ){
			$create_dir = ARMDataHandler::createRecursiveFoldersIfNotExists($this->_config->cache_folder);
			if( ! $create_dir ){
				throw new ErrorException( "CACHE-ERROR:: Can't create  folder - ". getcwd() . DIRECTORY_SEPARATOR .$this->_config->cache_folder ) ;
//				ARMDebug::error(  "CACHE-ERROR:: Cache folder  NOT FOUND - ". getcwd() . DIRECTORY_SEPARATOR .$this->_config->cache_folder  ) ;
			}
		} else if (!is_writable($this->_config->cache_folder)){
//			ARMDebug::error(  "CACHE-ERROR:: Cache folder is NOT writable - ". getcwd() . DIRECTORY_SEPARATOR .$this->_config->cache_folder  ) ;
			throw new ErrorException( "CACHE-ERROR:: Cache folder is NOT writable - ". getcwd() . DIRECTORY_SEPARATOR .$this->_config->cache_folder ) ;
//			die;
		}
	}


	/**
	 * @var ARMCacheConfigVO
	 */
	protected $_config;

	/**
	 * @var ARMBaseCacheVO
	 */
	protected $_cacheVO;

	protected $_cacheFilePath;

	/**
	 * 
	 * @param ARMBaseCacheVO $CacheVO
	 * @return ARMReturnResultVO
	 */
	private function getCacheFileContent( ){
		$returnResultVO = new ARMReturnResultVO() ;
		
		$cacheFilePath = $this->getCacheFilePath(  );
//		ARMDebug::error( "exite?" . ( $cacheFilePath ) );
//		ARMDebug::error(file_exists( $cacheFilePath ) );
		if( file_exists( $cacheFilePath ) ){
			if( $this->validateCacheFileUsage( ) ){
				$returnResultVO->success = TRUE ;
				$returnResultVO->addMessage("Using cacheFile");
				$returnResultVO->result =  $this->_cacheVO->parseFileContent( file_get_contents( $cacheFilePath ) ) ;

			} else {
				unlink( $cacheFilePath ) ;
			}
		}
		return $returnResultVO ;
	}

	/**
	 * @param ARMBaseCacheVO $CacheVO
	 * @param $cacheFilePath
	 * @return bool
	 */
	protected function validateCacheFileUsage() {
		$cacheFilePath = $this->getCacheFilePath( );

		// by default always use avaible cache file
		$use_cache  = TRUE ;

		// verifies if $_cacheVO has a expiration rule
		if( !is_null($this->_cacheVO->duration ) ){
			$use_cache = ARMCacheModule::isValidCacheFile( $cacheFilePath, $this->_cacheVO->duration );
		} elseif( $this->_config->general_expiration_rule && !is_null(  $this->_config->cache_duration )  ){
			$use_cache = ARMCacheModule::isValidCacheFile( $cacheFilePath, $this->_config->cache_duration );
		} elseif (   $this->_config->general_expiration_rule && is_null(  $this->_config->cache_duration ) ){
			//  global rules  = ON
			// expiration = NULL    that means the cache will never expires so USE IT!
			return TRUE;

		} else{
			throw new ErrorException( "CACHE-ERROR:: Cant't determine if cache file is valid general rule is OFF and _cacheVO has no duration" ) ;
		}

		return $use_cache;
	}

	/**
	 * valida arquivo informado baseado no config::Cache_file_duration
	 * @param string $file_path
	 * @return boolean
	 */
	public static function isValidCacheFile( $file_path , $duration ){
		$interval =  new DateInterval( $duration ) ;
		$fileTime =  filemtime(  $file_path  ) ;
		$cacheLimitTime = new DateTime("now");
		$cacheLimitTime->sub( $interval );

//		ARMDebug::error("<hr>");

		$return = ( $fileTime > $cacheLimitTime->getTimestamp() ) ;
//		ARMDebug::dump( $fileTime , $cacheLimitTime->getTimestamp() , $return );
//		ARMDebug::error("<hr>");
		return $return;
	}



	protected function getCacheFilePath(){
		return  $this->_cacheFilePath ;
	}

	
	private  function setCacheFileContent( $data ){


		$returnResultVO = new ARMReturnResultVO();
		$returnResultVO->success = TRUE ;
		
		$cacheFilePath = $this->getCacheFilePath();

		if( !ARMDataHandler::writeFile( $cacheFilePath , "",  $this->_cacheVO->parseDataToFileContent( $data ) ,  "w+" ) ){
			$returnResultVO->success = FALSE ;
			$returnResultVO->addMessage("erro ao escrever arquivo de cache - " . $cacheFilePath );
		} else{
			$returnResultVO->addMessage("arquivo de cache criado - " . $cacheFilePath );
		}

		$returnResultVO->result = $data ;

		return $returnResultVO ;
	}


	protected function setCacheVO( ARMCacheDataVO $CacheDataVO ){

		$this->_cacheVO  = $CacheDataVO ;

		$cacheFolderPath = $this->_config->cache_folder . DIRECTORY_SEPARATOR .   $this->_cacheVO->getFileDirectory() ;
		$cacheFilePath = $cacheFolderPath  . DIRECTORY_SEPARATOR . $this->_cacheVO->getFileName();
		ARMDataHandler::createRecursiveFoldersIfNotExists( $cacheFolderPath  );

		$this->_cacheFilePath = ARMDataHandler::removeDoubleBars( $cacheFilePath  );
	}

	/**
	 * 
	 * @param ARMCacheDataVO $CacheDataVO
	 * @return ARMReturnResultVO
	 */
	public function getCache( ARMCacheDataVO $CacheDataVO ){

		$this->setCacheVO( $CacheDataVO ) ;

		$cacheContent = $this->getCacheFileContent( );


		if( $cacheContent->success == TRUE )
			return $cacheContent ;
		
		
		$cacheFilePath = $this->getCacheFilePath();
		
		// code to generate new content
		$params = array();
		if( $CacheDataVO->params != NULL ){
			$params = $CacheDataVO->params ;
		}
		
		if( is_object( $CacheDataVO->class ) ){
			
			if( method_exists( $CacheDataVO->class , $CacheDataVO->method ) ){
				$cl = $CacheDataVO->class ;
				$mt = $CacheDataVO->method ;
				
				$data  = call_user_func_array( array(  $CacheDataVO->class , $CacheDataVO->method  ) , $params );
				
				return $this->setCacheFileContent(   $data  ) ; //json_encode( $data ) ) ;
				
			}else{
				$cacheContent->addMessage(  $CacheDataVO->class .  "->" . $CacheDataVO->method . "  não EXISTE ou não é  PÚBLICO");
			}
		}
		
		return $cacheContent ;
	}
	
	/**
	 * 
	 * @param ARMCacheHttpVO $CacheHttpVO
	 * @return ARMReturnResultVO
	 */
	public function getCacheHttRequest( ARMCacheHttpVO $CacheHttpVO ){
		
		$cacheContent = new ARMReturnResultVO();
		
		if( !ARMValidation::validateUrl( $CacheHttpVO->urlRequest ) ){
			$cacheContent->addMessage( $CacheHttpVO->urlRequest .  " não é uma URL válida no sistema");
			return $cacheContent ;
		}
		
		$cacheContent = $this->getCacheFileContent( $CacheHttpVO );
		
		
		if( $cacheContent->success == TRUE )
			return $cacheContent ;
		
		// code to generate new content
		$cacheFilePath = $CacheHttpVO->getFileDirectory() . $CacheHttpVO->getFileName() ;
		
		$client = new Zend_Http_Client( $CacheHttpVO->urlRequest );
		
		if( $CacheHttpVO->params != NULL ){
			foreach( $CacheHttpVO->params as $key => $value ){
				$client->setParameterPost( $key , $value ) ;
			}
		}
		
		$response = $client->request('POST')  ;
		if( $response->getStatus() != 200 ){
			$cacheContent->addMessage( "ERROR -  HTTP STATUS:  " . $response->getStatus()  );
			return $cacheContent ;
		}
		
		$data = $response->getBody() ;
		
		return $this->setCacheFileContent( $CacheHttpVO , $data ) ;
		
	}
	
	
}

?>